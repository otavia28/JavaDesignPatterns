# 面向对象软件设计原则
## 单一职责原则
一个对象只包含单一的职责，并且该职责被完整地封装在一个类中。比如图书管理的类不能去进行用户管理的操作。
> 比如存在一个类 People，既能唱歌、又能跳舞、又能 rap、又能打篮球。
> 
> 如果遵循单一职责原则，就得把这个类 People 细分成四个类 Singer、Dancer、Rapper、Player，各司其职。
## 开闭原则
软件实体应该对扩展开放，对修改关闭。
> 比如我们可以对一个需要扩展的类抽象成一个接口或抽象类，这样就满足了第一个要求：对扩展开放。
> 
> 而每个人想扩展的功能不同，想扩展什么功能就创建自己的继承类继承这个抽象类然后实现抽象类中的抽象方法，而不是修改其他人的继承类，这样就满足了第二个要求：对修改关闭。
## 里氏替换原则
子类可以扩展父类的功能，但不能改变父类原有的功能。
> 子类可以实现父类的抽象方法，但不能重写父类的非抽象方法。
## 依赖倒转原则
传统的依赖关系是高层模块直接调用低层模块（即高层依赖低层），而倒转后高层和低层模块都依赖于抽象接口或抽象类，而具体实现隐藏在抽象后。
> 传统的依赖关系是：B 类中创建 A 类实例调用 A，C 类中创建 B 类实例调用 B。
> 
> 而依赖倒转原则是：A、B、C 类都有各自对应的接口，
## 接口隔离原则
设备不应该依赖那些它不需要的接口。需要将接口进行细粒度划分，不同的设备根据其需要实现的功能依赖不同的接口。
> 比如存在一个接口 Device，声明了 getCpu、getMemory、getType。类 Computer 和 Fan 都实现 Device。
> 
> 如果遵循接口隔离原则，则需要细分接口 Device 为 SmartDevice 和 NormalDevice，分别声明 getCpu、getMemory、getType 和 getType。然后让类 Computer 和 Fan 分别实现。
## 合成复用原则
相较于继承复用，应该优先考虑合成复用降低耦合度。即不是在 B 中继承 A 然后用 B，而是在 B 中用 A。
```java
class A {
    public void hello() {
        System.out.println("hello");
    }
}
// 不符合合成复用原则
class B extends A{
    public void say() {
        System.out.println("你好");
        hello();
    }
}
// 符合合成复用原则
class C {
    public void say(A a) {
        System.out.println("你好");
        a.hello();
    }
}
```
## 迪米特法则（最少知识原则）
一个类或模块对其他的类或模块有越少的交互越好，降低耦合度。
> 比如类 B 需要打印类 A 的价钱，如果不符合迪米特法则的话，外层调用 B 打印方法时的参数为 A 的信息，然后再 B 类内部将 A 的价钱从信息中提取出来进行打印。
> 
> 如果符合迪米特法则的话，外层调用 B 打印方法时先从 A 的信息中提取出价钱，再把价钱作为参数进行调用。
